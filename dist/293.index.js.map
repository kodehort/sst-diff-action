{"version":3,"file":"293.index.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA","sources":["webpack://sst-diff-action/./node_modules/.pnpm/sst@2.11.14/node_modules/sst/runtime/handlers/go.js"],"sourcesContent":["import path from \"path\";\nimport fs from \"fs/promises\";\nimport os from \"os\";\nimport { useRuntimeHandlers } from \"../handlers.js\";\nimport { useRuntimeWorkers } from \"../workers.js\";\nimport { Context } from \"../../context/context.js\";\nimport { VisibleError } from \"../../error.js\";\nimport { spawn } from \"child_process\";\nimport { useRuntimeServerConfig } from \"../server.js\";\nimport { isChild } from \"../../util/fs.js\";\nimport { execAsync } from \"../../util/process.js\";\nexport const useGoHandler = Context.memo(async () => {\n    const workers = await useRuntimeWorkers();\n    const server = await useRuntimeServerConfig();\n    const handlers = useRuntimeHandlers();\n    const processes = new Map();\n    const sources = new Map();\n    const handlerName = process.platform === \"win32\" ? `bootstrap.exe` : `bootstrap`;\n    handlers.register({\n        shouldBuild: (input) => {\n            const parent = sources.get(input.functionID);\n            if (!parent)\n                return false;\n            return isChild(parent, input.file);\n        },\n        canHandle: (input) => input.startsWith(\"go\"),\n        startWorker: async (input) => {\n            const proc = spawn(path.join(input.out, handlerName), {\n                env: {\n                    ...process.env,\n                    ...input.environment,\n                    IS_LOCAL: \"true\",\n                    AWS_LAMBDA_RUNTIME_API: `localhost:${server.port}/${input.workerID}`,\n                },\n                cwd: input.out,\n            });\n            proc.on(\"exit\", () => workers.exited(input.workerID));\n            proc.stdout.on(\"data\", (data) => {\n                workers.stdout(input.workerID, data.toString());\n            });\n            proc.stderr.on(\"data\", (data) => {\n                workers.stdout(input.workerID, data.toString());\n            });\n            processes.set(input.workerID, proc);\n        },\n        stopWorker: async (workerID) => {\n            const proc = processes.get(workerID);\n            if (proc) {\n                proc.kill();\n                processes.delete(workerID);\n            }\n        },\n        build: async (input) => {\n            const parsed = path.parse(input.props.handler);\n            const project = await find(parsed.dir, \"go.mod\");\n            sources.set(input.functionID, project);\n            const src = path.relative(project, input.props.handler);\n            if (input.mode === \"start\") {\n                try {\n                    const target = path.join(input.out, handlerName);\n                    const srcPath = os.platform() === \"win32\" ? src.replaceAll(\"\\\\\", \"\\\\\\\\\") : src;\n                    const result = await execAsync(`go build -ldflags \"-s -w\" -o \"${target}\" ./${srcPath}`, {\n                        cwd: project,\n                        env: {\n                            ...process.env,\n                        },\n                    });\n                }\n                catch (ex) {\n                    return {\n                        type: \"error\",\n                        errors: [String(ex)],\n                    };\n                }\n            }\n            if (input.mode === \"deploy\") {\n                try {\n                    const target = path.join(input.out, \"bootstrap\");\n                    const srcPath = os.platform() === \"win32\" ? src.replaceAll(\"\\\\\", \"\\\\\\\\\") : src;\n                    await execAsync(`go build -ldflags \"-s -w\" -o \"${target}\" ./${srcPath}`, {\n                        cwd: project,\n                        env: {\n                            ...process.env,\n                            CGO_ENABLED: \"0\",\n                            GOARCH: input.props.architecture === \"arm_64\" ? \"arm64\" : \"amd64\",\n                            GOOS: \"linux\",\n                        },\n                    });\n                }\n                catch (ex) {\n                    return {\n                        type: \"error\",\n                        errors: [String(ex)],\n                    };\n                }\n            }\n            return {\n                type: \"success\",\n                handler: \"bootstrap\",\n            };\n        },\n    });\n});\nasync function find(dir, target) {\n    if (dir === \"/\")\n        throw new VisibleError(`Could not find a ${target} file`);\n    if (await fs\n        .access(path.join(dir, target))\n        .then(() => true)\n        .catch(() => false))\n        return dir;\n    return find(path.join(dir, \"..\"), target);\n}\n"],"names":[],"sourceRoot":""}