{"version":3,"file":"287.index.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACpdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://sst-diff-action/./node_modules/.pnpm/sst@2.11.14/node_modules/sst/constructs/App.js","webpack://sst-diff-action/./node_modules/.pnpm/sst@2.11.14/node_modules/sst/constructs/Auth.js","webpack://sst-diff-action/./node_modules/.pnpm/sst@2.11.14/node_modules/sst/constructs/FunctionalStack.js"],"sourcesContent":["import path from \"path\";\nimport fs from \"fs\";\nimport { Stack } from \"./Stack.js\";\nimport { isSSTConstruct, isStackConstruct, } from \"./Construct.js\";\nimport { Function } from \"./Function.js\";\nimport { bindParameters, bindType } from \"./util/functionBinding.js\";\nimport { stack } from \"./FunctionalStack.js\";\nimport { createRequire } from \"module\";\nimport { Auth } from \"./Auth.js\";\nimport { useDeferredTasks } from \"./deferred_task.js\";\nimport { AppContext } from \"./context.js\";\nimport { useProject } from \"../project.js\";\nimport { Logger } from \"../logger.js\";\nimport { App as CDKApp, Tags, CfnResource, RemovalPolicy, CustomResourceProvider, CustomResourceProviderRuntime, CustomResource, Aspects, } from \"aws-cdk-lib/core\";\nimport { CfnFunction } from \"aws-cdk-lib/aws-lambda\";\nimport { Bucket } from \"aws-cdk-lib/aws-s3\";\nimport { ArnPrincipal, PolicyStatement } from \"aws-cdk-lib/aws-iam\";\nimport { CfnLogGroup } from \"aws-cdk-lib/aws-logs\";\nconst require = createRequire(import.meta.url);\nfunction exitWithMessage(message) {\n    console.error(message);\n    process.exit(1);\n}\n/**\n * The App construct extends cdk.App and is used internally by SST.\n */\nexport class App extends CDKApp {\n    /**\n     * Whether or not the app is running locally under `sst start`\n     */\n    local = false;\n    /**\n     * Whether the app is running locally under start, deploy or remove\n     */\n    mode;\n    /**\n     * The name of your app, comes from the `name` in your `sst.config.ts`\n     */\n    name;\n    /**\n     * The stage the app is being deployed to. If this is not specified as the --stage option, it'll default to the stage configured during the initial run of the SST CLI.\n     */\n    stage;\n    /**\n     * The region the app is being deployed to. If this is not specified as the --region option in the SST CLI, it'll default to the region in your sst.config.ts.\n     */\n    region;\n    /**\n     * The AWS account the app is being deployed to. This comes from the IAM credentials being used to run the SST CLI.\n     */\n    account;\n    /** @internal */\n    debugStartedAt;\n    /** @internal */\n    debugIncreaseTimeout;\n    /** @internal */\n    appPath;\n    /** @internal */\n    isActiveStack;\n    /** @internal */\n    defaultFunctionProps;\n    _defaultRemovalPolicy;\n    /** @internal */\n    get defaultRemovalPolicy() {\n        return this._defaultRemovalPolicy;\n    }\n    /**\n     * @internal\n     */\n    constructor(deployProps, props = {}) {\n        super(props);\n        AppContext.provide(this);\n        this.appPath = process.cwd();\n        this.mode = deployProps.mode;\n        this.local = this.mode === \"dev\";\n        this.stage = deployProps.stage || \"dev\";\n        this.name = deployProps.name || \"my-app\";\n        this.region =\n            deployProps.region || process.env.CDK_DEFAULT_REGION || \"us-east-1\";\n        this.account =\n            deployProps.account || process.env.CDK_DEFAULT_ACCOUNT || \"my-account\";\n        this.isActiveStack = deployProps.isActiveStack;\n        this.defaultFunctionProps = [];\n        if (this.mode === \"dev\") {\n            this.debugStartedAt = deployProps.debugStartedAt;\n            this.debugIncreaseTimeout = deployProps.debugIncreaseTimeout;\n        }\n    }\n    /**\n     * Use this method to prefix resource names in your stacks to make sure they don't thrash when deployed to different stages in the same AWS account. This method will prefix a given resource name with the stage and app name. Using the format `${stage}-${name}-${logicalName}`.\n     * @example\n     * ```js\n     * console.log(app.logicalPrefixedName(\"myTopic\"));\n     *\n     * // dev-my-app-myTopic\n     * ```\n     */\n    logicalPrefixedName(logicalName) {\n        const namePrefix = this.name === \"\" ? \"\" : `${this.name}-`;\n        return `${this.stage}-${namePrefix}${logicalName}`;\n    }\n    /**\n     * The default removal policy that'll be applied to all the resources in the app. This can be useful to set ephemeral (dev or feature branch) environments to remove all the resources on deletion.\n     * :::danger\n     * Make sure to not set the default removal policy to `DESTROY` for production environments.\n     * :::\n     * @example\n     * ```js\n     * app.setDefaultRemovalPolicy(app.mode === \"dev\" ? \"destroy\" : \"retain\")\n     * ```\n     */\n    setDefaultRemovalPolicy(policy) {\n        this._defaultRemovalPolicy = policy;\n    }\n    /**\n     * The default function props to be applied to all the Lambda functions in the app. These default values will be overridden if a Function sets its own props.\n     * This needs to be called before a stack with any functions have been added to the app.\n     *\n     * @example\n     * ```js\n     * app.setDefaultFunctionProps({\n     *   runtime: \"nodejs12.x\",\n     *   timeout: 30\n     * })\n     * ```\n     */\n    setDefaultFunctionProps(props) {\n        this.defaultFunctionProps.push(props);\n    }\n    /**\n     * Adds additional default Permissions to be applied to all Lambda functions in the app.\n     *\n     * @example\n     * ```js\n     * app.addDefaultFunctionPermissions([\"s3\"])\n     * ```\n     */\n    addDefaultFunctionPermissions(permissions) {\n        this.defaultFunctionProps.push({\n            permissions,\n        });\n    }\n    /**\n     * Adds additional default environment variables to be applied to all Lambda functions in the app.\n     *\n     * @example\n     * ```js\n     * app.addDefaultFunctionEnv({\n     *   \"MY_ENV_VAR\": \"my-value\"\n     * })\n     * ```\n     */\n    addDefaultFunctionEnv(environment) {\n        this.defaultFunctionProps.push({\n            environment,\n        });\n    }\n    /**\n     * Binds additional default resources to be applied to all Lambda functions in the app.\n     *\n     * @example\n     * ```js\n     * app.addDefaultFunctionBinding([STRIPE_KEY, bucket]);\n     * ```\n     */\n    addDefaultFunctionBinding(bind) {\n        this.defaultFunctionProps.push({ bind });\n    }\n    /**\n     * Adds additional default layers to be applied to all Lambda functions in the stack.\n     */\n    addDefaultFunctionLayers(layers) {\n        this.defaultFunctionProps.push({\n            layers,\n        });\n    }\n    isFinished = false;\n    async finish() {\n        if (this.isFinished)\n            return;\n        this.isFinished = true;\n        await useDeferredTasks().run();\n        Auth.injectConfig();\n        this.buildConstructsMetadata();\n        this.ensureUniqueConstructIds();\n        this.codegenTypes();\n        this.createBindingSsmParameters();\n        this.removeGovCloudUnsupportedResourceProperties();\n        const { config } = useProject();\n        for (const child of this.node.children) {\n            if (isStackConstruct(child)) {\n                // Tag stacks\n                Tags.of(child).add(\"sst:app\", this.name);\n                Tags.of(child).add(\"sst:stage\", this.stage);\n                // Set removal policy\n                if (this._defaultRemovalPolicy)\n                    this.applyRemovalPolicy(child, this._defaultRemovalPolicy);\n                // Stack names need to be parameterized with the stage name\n                if (config.advanced?.disableParameterizedStackNameCheck !== true &&\n                    !child.stackName.startsWith(`${this.stage}-`) &&\n                    !child.stackName.endsWith(`-${this.stage}`) &&\n                    child.stackName.indexOf(`-${this.stage}-`) === -1) {\n                    throw new Error(`Stack \"${child.stackName}\" is not parameterized with the stage name. The stack name needs to either start with \"$stage-\", end in \"-$stage\", or contain the stage name \"-$stage-\".`);\n                }\n            }\n        }\n    }\n    isRunningSSTTest() {\n        // Check the env var set inside test/setup-tests.js\n        return process.env.SST_RESOURCES_TESTS === \"enabled\";\n    }\n    getInputFilesFromEsbuildMetafile(file) {\n        let metaJson;\n        try {\n            metaJson = JSON.parse(fs.readFileSync(file).toString());\n        }\n        catch (e) {\n            exitWithMessage(\"There was a problem reading the esbuild metafile.\");\n        }\n        return Object.keys(metaJson.inputs).map((input) => path.resolve(input));\n    }\n    createBindingSsmParameters() {\n        class CreateSsmParameters {\n            visit(c) {\n                if (!isSSTConstruct(c)) {\n                    return;\n                }\n                if (c instanceof Function && c._doNotAllowOthersToBind) {\n                    return;\n                }\n                bindParameters(c);\n            }\n        }\n        Aspects.of(this).add(new CreateSsmParameters());\n    }\n    buildConstructsMetadata() {\n        const constructs = this.buildConstructsMetadata_collectConstructs(this);\n        const byStack = {};\n        const local = [];\n        for (const c of constructs) {\n            const stack = Stack.of(c);\n            const list = byStack[stack.node.id] || [];\n            const metadata = c.getConstructMetadata();\n            const item = {\n                id: c.node.id,\n                addr: c.node.addr,\n                stack: Stack.of(c).stackName,\n                ...metadata,\n            };\n            local.push(item);\n            list.push({\n                ...item,\n                local: undefined,\n            });\n            byStack[stack.node.id] = list;\n        }\n        // Register constructs\n        for (const child of this.node.children) {\n            if (child instanceof Stack) {\n                const stackName = child.node.id;\n                child.addOutputs({\n                    SSTMetadata: JSON.stringify({\n                        app: this.name,\n                        stage: this.stage,\n                        version: useProject().version,\n                        metadata: byStack[stackName] || [],\n                    }),\n                });\n            }\n        }\n    }\n    buildConstructsMetadata_collectConstructs(construct) {\n        return [\n            isSSTConstruct(construct) ? construct : undefined,\n            ...construct.node.children.flatMap((c) => this.buildConstructsMetadata_collectConstructs(c)),\n        ].filter((c) => Boolean(c));\n    }\n    applyRemovalPolicy(current, policy) {\n        if (current instanceof CfnResource) {\n            current.applyRemovalPolicy(RemovalPolicy[policy.toUpperCase()]);\n        }\n        // Had to copy this in to enable deleting objects in bucket\n        // https://github.com/aws/aws-cdk/blob/master/packages/%40aws-cdk/aws-s3/lib/bucket.ts#L1910\n        if (current instanceof Bucket &&\n            !current.node.tryFindChild(\"AutoDeleteObjectsCustomResource\")) {\n            const AUTO_DELETE_OBJECTS_RESOURCE_TYPE = \"Custom::S3AutoDeleteObjects\";\n            const provider = CustomResourceProvider.getOrCreateProvider(current, AUTO_DELETE_OBJECTS_RESOURCE_TYPE, {\n                codeDirectory: path.join(require.resolve(\"aws-cdk-lib/aws-s3\"), \"../lib/auto-delete-objects-handler\"),\n                runtime: CustomResourceProviderRuntime.NODEJS_16_X,\n                description: `Lambda function for auto-deleting objects in ${current.bucketName} S3 bucket.`,\n            });\n            // Use a bucket policy to allow the custom resource to delete\n            // objects in the bucket\n            current.addToResourcePolicy(new PolicyStatement({\n                actions: [\n                    // list objects\n                    \"s3:GetBucket*\",\n                    \"s3:List*\",\n                    // and then delete them\n                    \"s3:DeleteObject*\",\n                ],\n                resources: [current.bucketArn, current.arnForObjects(\"*\")],\n                principals: [new ArnPrincipal(provider.roleArn)],\n            }));\n            const customResource = new CustomResource(current, \"AutoDeleteObjectsCustomResource\", {\n                resourceType: AUTO_DELETE_OBJECTS_RESOURCE_TYPE,\n                serviceToken: provider.serviceToken,\n                properties: {\n                    BucketName: current.bucketName,\n                },\n            });\n            // Ensure bucket policy is deleted AFTER the custom resource otherwise\n            // we don't have permissions to list and delete in the bucket.\n            // (add a `if` to make TS happy)\n            if (current.policy) {\n                customResource.node.addDependency(current.policy);\n            }\n        }\n        current.node.children.forEach((resource) => this.applyRemovalPolicy(resource, policy));\n    }\n    removeGovCloudUnsupportedResourceProperties() {\n        if (!this.region.startsWith(\"us-gov-\")) {\n            return;\n        }\n        class RemoveGovCloudUnsupportedResourceProperties {\n            visit(node) {\n                if (node instanceof CfnFunction) {\n                    node.addPropertyDeletionOverride(\"EphemeralStorage\");\n                }\n                else if (node instanceof CfnLogGroup) {\n                    node.addPropertyDeletionOverride(\"Tags\");\n                }\n            }\n        }\n        Aspects.of(this).add(new RemoveGovCloudUnsupportedResourceProperties());\n    }\n    ensureUniqueConstructIds() {\n        // \"ids\" has the shape of:\n        // {\n        //   Table: {\n        //     \"id_with_hyphen\": \"id-with-hyphen\",\n        //     \"id_with_underscore\": \"id_with_underscore\",\n        //   }\n        // }\n        const ids = {};\n        class EnsureUniqueConstructIds {\n            visit(c) {\n                if (!isSSTConstruct(c)) {\n                    return;\n                }\n                if (c instanceof Function && c._doNotAllowOthersToBind) {\n                    return;\n                }\n                const className = c.constructor.name;\n                const id = c.id;\n                const normId = id.replace(/-/g, \"_\");\n                const existingIds = ids[className] || {};\n                if (!id.match(/^[a-zA-Z]([a-zA-Z0-9-_])*$/)) {\n                    throw new Error([\n                        `Invalid id \"${id}\" for ${className} construct.`,\n                        ``,\n                        `Starting v1.16, construct ids can only contain alphabetic characters, hyphens (\"-\"), and underscores (\"_\"), and must start with an alphabetic character. If you are migrating from version 1.15 or earlier, please see the upgrade guide — https://docs.serverless-stack.com/upgrade-guide#upgrade-to-v116`,\n                    ].join(\"\\n\"));\n                }\n                else if ([\"Parameter\", \"Secret\"].includes(className)) {\n                    const existingConfigId = ids.Secret?.[normId] || ids.Parameter?.[normId];\n                    if (existingConfigId === id) {\n                        throw new Error(`ERROR: Config with id \"${id}\" already exists.`);\n                    }\n                    else if (existingConfigId) {\n                        throw new Error(`ERROR: You cannot have the same Config id with an underscore and hyphen: \"${existingConfigId}\" and \"${id}\".`);\n                    }\n                }\n                else if (existingIds[normId]) {\n                    throw new Error([\n                        existingIds[normId] === id\n                            ? `${className} with id \"${id}\" already exists.`\n                            : `You cannot have the same ${className} id with an underscore and hyphen: \"${existingIds[normId]}\" and \"${id}\".`,\n                        ``,\n                        `Starting v1.16, constructs must have unique ids for a given construct type. If you are migrating from version 1.15 or earlier, set the \"cdk.id\" in the construct with the existing id, and pick a unique id for the construct. Please see the upgrade guide — https://docs.serverless-stack.com/upgrade-guide#upgrade-to-v116`,\n                        ``,\n                        `    For example, if you have two Bucket constructs with the same id:`,\n                        `      new Bucket(this, \"bucket\");`,\n                        `      new Bucket(this, \"bucket\");`,\n                        ``,\n                        `    Change it to:`,\n                        `      new Bucket(this, \"usersBucket\", {`,\n                        `        cdk: {`,\n                        `          id: \"bucket\"`,\n                        `        }`,\n                        `      });`,\n                        `      new Bucket(this, \"adminBucket\", {`,\n                        `        cdk: {`,\n                        `          id: \"bucket\"`,\n                        `        }`,\n                        `      });`,\n                    ].join(\"\\n\"));\n                }\n                existingIds[normId] = id;\n                ids[className] = existingIds;\n            }\n        }\n        Aspects.of(this).add(new EnsureUniqueConstructIds());\n    }\n    codegenTypes() {\n        const project = useProject();\n        const typesPath = path.resolve(project.paths.out, \"types\");\n        Logger.debug(`Generating types in ${typesPath}`);\n        fs.rmSync(typesPath, {\n            recursive: true,\n            force: true,\n        });\n        fs.mkdirSync(typesPath, {\n            recursive: true,\n        });\n        fs.appendFileSync(`${typesPath}/index.ts`, [\n            `import \"sst/node/config\";`,\n            `declare module \"sst/node/config\" {`,\n            `  export interface ConfigTypes {`,\n            `    APP: string;`,\n            `    STAGE: string;`,\n            `  }`,\n            `}`,\n        ].join(\"\\n\"));\n        class CodegenTypes {\n            visit(c) {\n                if (!isSSTConstruct(c)) {\n                    return;\n                }\n                if (c instanceof Function && c._doNotAllowOthersToBind) {\n                    return;\n                }\n                const binding = bindType(c);\n                if (!binding) {\n                    return;\n                }\n                const className = c.constructor.name;\n                const id = c.id;\n                // Case 1: variable does not have properties, ie. Secrets and Parameters\n                fs.appendFileSync(`${typesPath}/index.ts`, (binding.variables[0] === \".\"\n                    ? [\n                        `import \"sst/node/${binding.clientPackage}\";`,\n                        `declare module \"sst/node/${binding.clientPackage}\" {`,\n                        `  export interface ${className}Resources {`,\n                        `    \"${id}\": string;`,\n                        `  }`,\n                        `}`,\n                    ]\n                    : [\n                        `import \"sst/node/${binding.clientPackage}\";`,\n                        `declare module \"sst/node/${binding.clientPackage}\" {`,\n                        `  export interface ${className}Resources {`,\n                        `    \"${id}\": {`,\n                        ...binding.variables.map((p) => `      ${p}: string;`),\n                        `    }`,\n                        `  }`,\n                        `}`,\n                    ]).join(\"\\n\"));\n            }\n        }\n        Aspects.of(this).add(new CodegenTypes());\n    }\n    // Functional Stack\n    // This is a magical global to avoid having to pass app everywhere.\n    // We only every have one instance of app\n    stack(fn, props) {\n        return stack(this, fn, props);\n    }\n}\n","import * as ssm from \"aws-cdk-lib/aws-ssm\";\nimport { Effect, Policy, PolicyStatement } from \"aws-cdk-lib/aws-iam\";\nimport { Construct } from \"constructs\";\nimport { Stack } from \"./Stack.js\";\nimport { getEnvironmentKey, getParameterPath, placeholderSecretValue, } from \"./util/functionBinding.js\";\nimport { CustomResource } from \"aws-cdk-lib/core\";\nconst PUBLIC_KEY_PROP = \"publicKey\";\nconst PRIVATE_KEY_PROP = \"privateKey\";\nconst PREFIX_PROP = \"prefix\";\n/**\n * SST Auth is a lightweight authentication solution for your applications. With a simple set of configuration you can deploy a function attached to your API that can handle various authentication flows.  *\n * @example\n * ```\n * import { Auth } from \"sst/constructs\"\n *\n * new Auth(stack, \"auth\", {\n *   authenticator: \"functions/authenticator.handler\"\n * })\n */\nexport class Auth extends Construct {\n    id;\n    authenticator;\n    apis = new Set();\n    /** @internal */\n    static list = new Set();\n    constructor(scope, id, props) {\n        super(scope, props.cdk?.id || id);\n        if (!props.authenticator ||\n            \"defaults\" in props ||\n            \"login\" in props ||\n            \"triggers\" in props ||\n            \"identityPoolFederation\" in props ||\n            \"cdk\" in props) {\n            throw new Error(`It looks like you may be passing in Cognito props to the Auth construct. The Auth construct was renamed to Cognito in version 1.10.0`);\n        }\n        Auth.list.add(this);\n        this.id = id;\n        const stack = Stack.of(scope);\n        this.authenticator = props.authenticator;\n        const policy = new Policy(this, \"CloudFrontInvalidatorPolicy\", {\n            statements: [\n                new PolicyStatement({\n                    actions: [\n                        \"ssm:GetParameter\",\n                        \"ssm:PutParameter\",\n                        \"ssm:DeleteParameter\",\n                    ],\n                    resources: [\n                        `arn:${stack.partition}:ssm:${stack.region}:${stack.account}:parameter/*`,\n                    ],\n                }),\n            ],\n        });\n        stack.customResourceHandler.role?.attachInlinePolicy(policy);\n        const resource = new CustomResource(this, \"StackMetadata\", {\n            serviceToken: stack.customResourceHandler.functionArn,\n            resourceType: \"Custom::AuthKeys\",\n            properties: {\n                publicPath: getParameterPath(this, PUBLIC_KEY_PROP),\n                privatePath: getParameterPath(this, PRIVATE_KEY_PROP),\n            },\n        });\n        resource.node.addDependency(policy);\n    }\n    /** @internal */\n    getConstructMetadata() {\n        return {\n            type: \"Auth\",\n            data: {},\n        };\n    }\n    /** @internal */\n    getFunctionBinding() {\n        const app = this.node.root;\n        return {\n            clientPackage: \"auth\",\n            variables: {\n                publicKey: {\n                    type: \"secret\",\n                },\n                // Example of referencing a secret\n                //publicKey2: {\n                //  type: \"secret_reference\",\n                //  secret: this.publicKey2,\n                //},\n            },\n            permissions: {\n                \"ssm:GetParameters\": [\n                    `arn:${Stack.of(this).partition}:ssm:${app.region}:${app.account}:parameter${getParameterPath(this, PUBLIC_KEY_PROP)}`,\n                ],\n            },\n        };\n    }\n    /**\n     * Attaches auth construct to an API\n     *\n     * @example\n     * ```js\n     * const api = new Api(stack, \"Api\", {});\n     * const auth = new Auth(stack, \"Auth\", {\n     *   authenticator: \"functions/authenticator.handler\"\n     * })\n     * auth.attach(stack, {\n     *   api\n     * })\n     * ```\n     */\n    attach(scope, props) {\n        const app = this.node.root;\n        // Validate: one Auth can only be attached to one Api\n        if (this.apis.has(props.api)) {\n            throw new Error(\"This Auth construct has already been attached to this Api construct.\");\n        }\n        // Validate: one Api can only have one Auth attached to it\n        if (Array.from(Auth.list).some((auth) => auth.apis.has(props.api))) {\n            throw new Error(\"This Api construct already has an Auth construct attached.\");\n        }\n        const prefix = props.prefix || \"/auth\";\n        for (let path of [`ANY ${prefix}/{proxy+}`, `GET ${prefix}`]) {\n            props.api.addRoutes(scope, {\n                [path]: {\n                    type: \"function\",\n                    function: this.authenticator,\n                    authorizer: \"none\",\n                },\n            });\n            // Auth construct has two types of Function bindinds:\n            // - Api routes: bindings defined in `getFunctionBinding()`\n            //     ie. calling `bind([auth])` will grant functions access to the public key\n            // - Auth authenticator: binds manually. Need to grant access to the prefix and private key\n            const fn = props.api.getFunction(path);\n            fn.addEnvironment(getEnvironmentKey(this, PREFIX_PROP), prefix);\n            fn.addEnvironment(getEnvironmentKey(this, PUBLIC_KEY_PROP), placeholderSecretValue());\n            fn.addEnvironment(getEnvironmentKey(this, PRIVATE_KEY_PROP), placeholderSecretValue());\n            fn.attachPermissions([\n                new PolicyStatement({\n                    actions: [\"ssm:GetParameters\"],\n                    effect: Effect.ALLOW,\n                    resources: [\n                        `arn:${Stack.of(this).partition}:ssm:${app.region}:${app.account}:parameter${getParameterPath(this, \"*\")}`,\n                    ],\n                }),\n            ]);\n        }\n        // Create a parameter for prefix\n        // note: currently if an Auth construct is attached to multiple Apis,\n        //       the prefix has to be the same for this to work.\n        if (this.apis.size === 0) {\n            new ssm.StringParameter(this, \"prefix\", {\n                parameterName: getParameterPath(this, PREFIX_PROP),\n                stringValue: prefix,\n            });\n        }\n        this.apis.add(props.api);\n    }\n    /**\n     * @internal\n     */\n    injectConfig() {\n        for (const api of this.apis) {\n            for (const route of api.routes) {\n                const fn = api.getFunction(route);\n                if (!fn)\n                    continue;\n                fn.bind([this]);\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    static injectConfig() {\n        for (const auth of Auth.list) {\n            auth.injectConfig();\n        }\n    }\n}\n","import { Stack } from \"./Stack.js\";\nexport function stack(app, fn, props) {\n    currentApp = app;\n    currentStack = fn;\n    const id = props?.id || fn.name;\n    const exists = getExports(app).has(fn);\n    if (exists)\n        throw new Error(`StackDuplicates: Attempting to initialize stack ${id} several times`);\n    class EmptyStack extends Stack {\n        constructor(scope, id, props) {\n            super(scope, id, props);\n        }\n    }\n    const stack = new EmptyStack(app, id, props);\n    getStacks(app).set(fn, stack);\n    const ctx = {\n        app,\n        stack,\n    };\n    const returns = fn.bind(stack)(ctx);\n    if (returns && \"then\" in returns)\n        return returns.then((data) => {\n            getExports(app).set(fn, data);\n        });\n    getExports(app).set(fn, returns);\n    return app;\n}\nlet currentApp;\nlet currentStack;\nconst exportsCache = new Map();\nconst stackCache = new Map();\nfunction getExports(app) {\n    if (!exportsCache.has(app))\n        exportsCache.set(app, new Map());\n    return exportsCache.get(app);\n}\nfunction getStacks(app) {\n    if (!stackCache.has(app))\n        stackCache.set(app, new Map());\n    return stackCache.get(app);\n}\nexport function use(stack) {\n    if (!currentApp)\n        throw new Error(\"No app is set\");\n    const exports = getExports(currentApp);\n    if (!exports.has(stack))\n        throw new Error(`StackWrongOrder: Initialize \"${stack.name}\" stack before \"${currentStack?.name}\" stack`);\n    return exports.get(stack);\n}\nexport function dependsOn(stack) {\n    const current = getStack(currentStack);\n    const target = getStack(stack);\n    current.addDependency(target);\n}\nexport function getStack(stack) {\n    if (!currentApp)\n        throw new Error(\"No app is set\");\n    const stacks = getStacks(currentApp);\n    if (!stacks.has(stack))\n        throw new Error(`StackWrongOrder: Initialize \"${stack.name}\" stack before \"${currentStack?.name}\" stack`);\n    return stacks.get(stack);\n}\n"],"names":[],"sourceRoot":""}