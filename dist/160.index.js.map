{"version":3,"file":"160.index.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://sst-diff-action/./node_modules/.pnpm/sst@2.11.14/node_modules/sst/runtime/handlers/rust.js"],"sourcesContent":["import path from \"path\";\nimport fs from \"fs/promises\";\nimport { useRuntimeHandlers } from \"../handlers.js\";\nimport { useRuntimeWorkers } from \"../workers.js\";\nimport { Context } from \"../../context/context.js\";\nimport { VisibleError } from \"../../error.js\";\nimport { exec, spawn } from \"child_process\";\nimport { promisify } from \"util\";\nimport { useRuntimeServerConfig } from \"../server.js\";\nimport { findAbove, isChild } from \"../../util/fs.js\";\nconst execAsync = promisify(exec);\nexport const useRustHandler = Context.memo(async () => {\n    const workers = await useRuntimeWorkers();\n    const server = await useRuntimeServerConfig();\n    const handlers = useRuntimeHandlers();\n    const processes = new Map();\n    const sources = new Map();\n    const handlerName = process.platform === \"win32\" ? `handler.exe` : `handler`;\n    handlers.register({\n        shouldBuild: (input) => {\n            if (!input.file.endsWith(\".rs\"))\n                return false;\n            const parent = sources.get(input.functionID);\n            if (!parent)\n                return false;\n            const result = isChild(parent, input.file);\n            return result;\n        },\n        canHandle: (input) => input.startsWith(\"rust\"),\n        startWorker: async (input) => {\n            const proc = spawn(path.join(input.out, handlerName), {\n                env: {\n                    ...process.env,\n                    ...input.environment,\n                    IS_LOCAL: \"true\",\n                    RUST_BACKTRACE: \"1\",\n                    AWS_LAMBDA_RUNTIME_API: `http://localhost:${server.port}/${input.workerID}`,\n                    AWS_LAMBDA_FUNCTION_MEMORY_SIZE: \"1024\",\n                },\n                cwd: input.out,\n            });\n            proc.on(\"exit\", () => workers.exited(input.workerID));\n            proc.stdout.on(\"data\", (data) => {\n                workers.stdout(input.workerID, data.toString());\n            });\n            proc.stderr.on(\"data\", (data) => {\n                workers.stdout(input.workerID, data.toString());\n            });\n            processes.set(input.workerID, proc);\n        },\n        stopWorker: async (workerID) => {\n            const proc = processes.get(workerID);\n            if (proc) {\n                proc.kill();\n                processes.delete(workerID);\n            }\n        },\n        build: async (input) => {\n            const parsed = path.parse(input.props.handler);\n            const project = await findAbove(parsed.dir, \"Cargo.toml\");\n            if (!project)\n                return {\n                    type: \"error\",\n                    errors: [\"Could not find a Cargo.toml file\"],\n                };\n            sources.set(input.functionID, project);\n            if (input.mode === \"start\") {\n                try {\n                    await execAsync(`cargo build --bin ${parsed.name}`, {\n                        cwd: project,\n                        env: {\n                            ...process.env,\n                        },\n                    });\n                    await fs.cp(path.join(project, `target/debug`, parsed.name), path.join(input.out, \"handler\"));\n                }\n                catch (ex) {\n                    throw new VisibleError(\"Failed to build\");\n                }\n            }\n            if (input.mode === \"deploy\") {\n                try {\n                    await execAsync(`cargo lambda build --release --bin ${parsed.name}`, {\n                        cwd: project,\n                        env: {\n                            ...process.env,\n                        },\n                    });\n                    await fs.cp(path.join(project, `target/lambda/`, parsed.name, \"bootstrap\"), path.join(input.out, \"bootstrap\"));\n                }\n                catch (ex) {\n                    throw new VisibleError(\"Failed to build\");\n                }\n            }\n            return {\n                type: \"success\",\n                handler: \"handler\",\n            };\n        },\n    });\n});\n"],"names":[],"sourceRoot":""}