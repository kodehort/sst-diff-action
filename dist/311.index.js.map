{"version":3,"file":"311.index.js","mappings":";;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://sst-diff-action/./node_modules/.pnpm/sst@2.11.14/node_modules/sst/cdk/cloudformation-deployments-wrapper.js"],"sourcesContent":["import { debug } from \"sst-aws-cdk/lib/logging.js\";\nimport { CloudFormationStack, TemplateParameters, waitForStackDelete, } from \"sst-aws-cdk/lib/api/util/cloudformation.js\";\nimport { ToolkitInfo } from \"sst-aws-cdk/lib/api/toolkit-info.js\";\nimport { addMetadataAssetsToManifest } from \"sst-aws-cdk/lib/assets.js\";\nimport { publishAssets } from \"sst-aws-cdk/lib/util/asset-publishing.js\";\nimport { AssetManifestBuilder } from \"sst-aws-cdk/lib/util/asset-manifest-builder.js\";\nimport { CloudFormationDeployments, } from \"./cloudformation-deployments.js\";\nimport { makeBodyParameter } from \"./deploy-stack.js\";\nimport { Context } from \"../context/context.js\";\nexport async function publishDeployAssets(sdkProvider, options) {\n    const { deployment, toolkitInfo, stackSdk, resolvedEnvironment, cloudFormationRoleArn, } = await useDeployment().get(sdkProvider, options);\n    await deployment.publishStackAssets(options.stack, toolkitInfo, {\n        buildAssets: options.buildAssets ?? true,\n        publishOptions: {\n            quiet: options.quiet,\n            parallel: options.assetParallelism,\n        },\n    });\n    return deployStack({\n        stack: options.stack,\n        noMonitor: true,\n        resolvedEnvironment,\n        deployName: options.deployName,\n        notificationArns: options.notificationArns,\n        quiet: options.quiet,\n        sdk: stackSdk,\n        sdkProvider,\n        roleArn: cloudFormationRoleArn,\n        reuseAssets: options.reuseAssets,\n        toolkitInfo,\n        tags: options.tags,\n        deploymentMethod: options.deploymentMethod,\n        force: options.force,\n        parameters: options.parameters,\n        usePreviousParameters: options.usePreviousParameters,\n        progress: options.progress,\n        ci: options.ci,\n        rollback: options.rollback,\n        hotswap: options.hotswap,\n        extraUserAgent: options.extraUserAgent,\n        resourcesToImport: options.resourcesToImport,\n        overrideTemplate: options.overrideTemplate,\n        assetParallelism: options.assetParallelism,\n    });\n}\nconst useDeployment = Context.memo(() => {\n    const state = new Map();\n    return {\n        async get(sdkProvider, options) {\n            const region = options.stack.environment.region;\n            if (!state.has(region)) {\n                const deployment = new CloudFormationDeployments({ sdkProvider });\n                const { stackSdk, resolvedEnvironment, cloudFormationRoleArn } = await deployment.prepareSdkFor(options.stack, options.roleArn);\n                const toolkitInfo = await ToolkitInfo.lookup(resolvedEnvironment, stackSdk, options.toolkitStackName);\n                // Do a verification of the bootstrap stack version\n                await deployment.validateBootstrapStackVersion(options.stack.stackName, options.stack.requiresBootstrapStackVersion, options.stack.bootstrapStackVersionSsmParameter, toolkitInfo);\n                state.set(region, {\n                    deployment,\n                    toolkitInfo,\n                    stackSdk,\n                    resolvedEnvironment,\n                    cloudFormationRoleArn,\n                });\n            }\n            return state.get(region);\n        },\n    };\n});\nasync function deployStack(options) {\n    const stackArtifact = options.stack;\n    const stackEnv = options.resolvedEnvironment;\n    options.sdk.appendCustomUserAgent(options.extraUserAgent);\n    const cfn = options.sdk.cloudFormation();\n    const deployName = options.deployName || stackArtifact.stackName;\n    let cloudFormationStack = await CloudFormationStack.lookup(cfn, deployName);\n    if (cloudFormationStack.stackStatus.isCreationFailure) {\n        debug(`Found existing stack ${deployName} that had previously failed creation. Deleting it before attempting to re-create it.`);\n        await cfn.deleteStack({ StackName: deployName }).promise();\n        const deletedStack = await waitForStackDelete(cfn, deployName);\n        if (deletedStack && deletedStack.stackStatus.name !== \"DELETE_COMPLETE\") {\n            throw new Error(`Failed deleting stack ${deployName} that had previously failed creation (current state: ${deletedStack.stackStatus})`);\n        }\n        // Update variable to mark that the stack does not exist anymore, but avoid\n        // doing an actual lookup in CloudFormation (which would be silly to do if\n        // we just deleted it).\n        cloudFormationStack = CloudFormationStack.doesNotExist(cfn, deployName);\n    }\n    // Detect \"legacy\" assets (which remain in the metadata) and publish them via\n    // an ad-hoc asset manifest, while passing their locations via template\n    // parameters.\n    const legacyAssets = new AssetManifestBuilder();\n    const assetParams = await addMetadataAssetsToManifest(stackArtifact, legacyAssets, options.toolkitInfo, options.reuseAssets);\n    const finalParameterValues = { ...options.parameters, ...assetParams };\n    const templateParams = TemplateParameters.fromTemplate(stackArtifact.template);\n    const stackParams = options.usePreviousParameters\n        ? templateParams.updateExisting(finalParameterValues, cloudFormationStack.parameters)\n        : templateParams.supplyAll(finalParameterValues);\n    const bodyParameter = await makeBodyParameter(stackArtifact, options.resolvedEnvironment, legacyAssets, options.toolkitInfo, options.sdk, options.overrideTemplate);\n    await publishAssets(legacyAssets.toManifest(stackArtifact.assembly.directory), options.sdkProvider, stackEnv, {\n        parallel: options.assetParallelism,\n    });\n    return {\n        isUpdate: cloudFormationStack.exists &&\n            cloudFormationStack.stackStatus.name !== \"REVIEW_IN_PROGRESS\",\n        params: {\n            StackName: deployName,\n            TemplateBody: bodyParameter.TemplateBody,\n            TemplateURL: bodyParameter.TemplateURL,\n            Parameters: stackParams.apiParameters,\n            Capabilities: [\n                \"CAPABILITY_IAM\",\n                \"CAPABILITY_NAMED_IAM\",\n                \"CAPABILITY_AUTO_EXPAND\",\n            ],\n            Tags: options.tags,\n        },\n    };\n}\n"],"names":[],"sourceRoot":""}